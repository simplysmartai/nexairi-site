name: Auto-merge regenerated PRs

on:
  pull_request:
    types: [labeled, opened, synchronize, reopened]

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.event.pull_request != null
    steps:
      - name: Check PR labels
        id: labels
        uses: actions/github-script@v6
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(l=>l.name);
            core.setOutput('has_automerge', labels.includes('automerge') ? 'yes' : 'no');

      - name: Exit if not labeled for auto-merge
        if: steps.labels.outputs.has_automerge != 'yes'
        run: |
          echo "PR is not labeled 'automerge'; skipping auto-merge"

      - name: Wait for checks to pass and merge
        if: steps.labels.outputs.has_automerge == 'yes'
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            // Poll checks until all are successful or timeout
            const sleep = (ms) => new Promise(r=>setTimeout(r,ms));
            const maxAttempts = 30; // ~15 minutes
            for (let attempt=0; attempt<maxAttempts; attempt++) {
              const { data: checks } = await github.checks.listForRef({owner, repo, ref: context.payload.pull_request.head.sha});
              const statuses = checks.check_runs.map(c=>c.conclusion || c.status);
              if (statuses.length>0 && statuses.every(s=>s==='success')) break;
              if (statuses.some(s=>['failure','cancelled','timed_out','action_required'].includes(s))) throw new Error('Checks failed; aborting auto-merge');
              await sleep(30000);
            }
            // Merge the PR
            await github.pulls.merge({owner, repo, pull_number: pr, merge_method: 'squash'});
            core.info(`Merged PR #${pr}`);